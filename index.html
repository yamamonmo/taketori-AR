<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>竹取りシュミュレーション</title> <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
  <style>
    body{margin:0;overflow:hidden}
    /* ---- Overlay (右下20%) ---- */
    .hud {
      position: fixed;
      right: 1.2rem;
      bottom: 1.2rem;
      width: 20vw;
      max-width: 420px;
      min-width: 220px;
      z-index: 9999;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
      font-size: 0.9rem;
      line-height: 1.4;
      border-radius: 12px;
      backdrop-filter: saturate(120%) blur(4px);
      box-shadow: 0 6px 24px rgba(0,0,0,0.3);
      pointer-events: auto;
    }
    .hud__inner{ padding: 0.8rem 0.9rem; }
    .hud__row{ display:flex; align-items:center; justify-content:space-between; gap:0.6rem; }
    .hud__btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(255,255,255,0.12);
      color: #fff;
      padding: 0.45rem 0.7rem;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .hud__btn:hover{ background: rgba(255,255,255,0.18); }
    .hud__title{ margin:0.4rem 0 0.2rem; font-weight:600; font-size:0.95rem; }
    .hud__kbd{
      display:inline-block; min-width: 1.6rem; text-align:center;
      padding: 0.05rem 0.35rem; margin: 0 0.2rem;
      border-radius: 6px; background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.25); font-weight:600;
    }
    .hud ul{ margin: 0.2rem 0 0; padding-left: 0.9rem; }
    .hud li{ margin: 0.2rem 0; }
  </style>
</head>
<body>
  <a-scene
    embedded
    vr-mode-ui="enabled:false"
    renderer="alpha:true; antialias:true; precision:mediump"
    arjs="sourceType: webcam; detectionMode: mono; maxDetectionRate: 30; 
          debugUIEnabled: true;  sourceWidth:640; sourceHeight:480; displayWidth:640; displayHeight:480"> <a-assets timeout="20000">
      <a-asset-item id="pandaModel" src="./assets/panda.glb" response-type="arraybuffer"></a-asset-item>
      <a-asset-item id="moonModel" src="./assets/moon.glb" response-type="arraybuffer"></a-asset-item>
    </a-assets>

    <a-marker id="markerPanda" type="pattern" url="./assets/pattern-panda.patt" emitevents="true">
      <a-entity id="panda"
      gltf-model="#pandaModel"
      visible="false"
      position="0 0 0"
      rotation="-90 0 0"
      scale="0.001 0.001 0.001"
      animation-mixer>
      </a-entity>
      <a-circle radius="0.5" rotation="-90 0 0" color="#f0e6d2" opacity="0.2"></a-circle>
    </a-marker>

    <a-marker id="markerMoon" type="pattern" url="./assets/pattern-moon.patt" emitevents="true">
      <a-entity id="moon"
      gltf-model="#moonModel"
      visible="false"
      position="0 0 0"
      rotation="-90 0 0"
      scale="0.001 0.001 0.001"
      animation-mixer>
      </a-entity>
      <a-circle radius="0.5" rotation="-90 0 0" color="#f0e6d2" opacity="0.2"></a-circle>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <div class="hud" aria-live="polite">
    <div class="hud__inner">
      <div class="hud__row">
        <div>表示コントロール</div>
        <button id="btnFullscreen" class="hud__btn" type="button" title="フルスクリーン切替">
          全画面にする
        </button>
      </div>
      <div class="hud__title">ホットキー</div>
      <ul>
        <li><span class="hud__kbd">[</span> / <span class="hud__kbd">]</span> … スケール 縮小 / 拡大</li>
        <li><span class="hud__kbd">↑</span> / <span class="hud__kbd">↓</span> … X回転（上下）</li>
        <li><span class="hud__kbd">←</span> / <span class="hud__kbd">→</span> … Y回転（左右）</li>
      </ul>
      <div style="margin-top:0.4rem; font-size:0.85rem; color:#aaa;">※操作は現在検出中のモデルに適用されます</div>
    </div>
  </div>

  <script>
    // マーカー/モデルの取得
    const markerPanda = document.getElementById('markerPanda');
    const panda       = document.getElementById('panda');
    const markerMoon  = document.getElementById('markerMoon');
    const moon        = document.getElementById('moon');

    const models = [panda, moon];
    let activeModel = null;

    // モデルの自動スケーリング処理を関数化 (以前修正済み)
    function autoScaleModel(modelEntity) {
      modelEntity.setAttribute('visible', 'true');
      console.log(`[GLB] ${modelEntity.id} model-loaded.`);

      const mesh = modelEntity.getObject3D('mesh');
      if (mesh) {
        mesh.updateMatrixWorld(true);
        const box = new AFRAME.THREE.Box3().setFromObject(mesh);
        const size = new AFRAME.THREE.Vector3(); box.getSize(size);
        console.log(`[GLB] ${modelEntity.id} size (m):`, size.x.toFixed(3), size.y.toFixed(3), size.z.toFixed(3));

        const targetLen = 0.005;
        const currentLen = Math.max(size.x, size.z);
        if (currentLen > 0) {
          const s = targetLen / currentLen;
          modelEntity.setAttribute('scale', `${s} ${s} ${s}`);
          console.log(`[ADJ] ${modelEntity.id} autoscale ->`, s.toFixed(5));
        } else {
          console.warn(`[GLB] ${modelEntity.id} size is zero? Check model content.`);
        }
      } else {
        console.warn(`[GLB] ${modelEntity.id} mesh not found on model-loaded.`);
      }
    }

    // マーカー検出ログ & アクティブモデル設定を共通化
    function setupMarker(markerEl, modelEl) {
      markerEl.addEventListener('markerFound', () => {
        console.log(`[AR] marker FOUND: ${modelEl.id}`);
        activeModel = modelEl;
      });
      markerEl.addEventListener('markerLost', () => {
        console.log(`[AR] marker LOST: ${modelEl.id}`);
        if (activeModel === modelEl) {
          activeModel = null;
        }
      });
    }

    setupMarker(markerPanda, panda);
    setupMarker(markerMoon, moon);


    // GLB読み込み成功/失敗時の処理
    models.forEach(model => {
      model.addEventListener('model-loaded', () => {
        autoScaleModel(model);
      });

      model.addEventListener('model-error', (e) => {
        console.error(`[GLB] ${model.id} model-error:`, e.detail);
        console.error('原因例: パス違い/404, Draco/KTX2テクスチャ未対応, 破損, 同一生成元/CORS など');
      });
    });


    // ==== フルスクリーン制御 (以前修正済み) ====
    const fsBtn = document.getElementById('btnFullscreen');

    function enterFullscreen(el) {
      const target = el || document.documentElement;
      const req = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
      if (req) req.call(target);
    }
    function exitFullscreen() {
      const exit = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
      if (exit) exit.call(document);
    }
    function isFullscreen() {
      return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    }
    function updateFsButton() {
      if (fsBtn) {
        fsBtn.textContent = isFullscreen() ? '全画面を解除' : '全画面にする';
      }
    }

    if (fsBtn) {
        fsBtn.addEventListener('click', () => {
            if (isFullscreen()) exitFullscreen(); else enterFullscreen(document.documentElement);
        });
        document.addEventListener('fullscreenchange', updateFsButton);
        document.addEventListener('webkitfullscreenchange', updateFsButton);
        updateFsButton();
    }
    // ==== ホットキー：ページスクロール抑制（変更なし） ====
    window.addEventListener('keydown', (ev) => {
      const arrowKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];
      if (arrowKeys.includes(ev.key)) ev.preventDefault();
    }, { passive: false });

    // ====== ホットキー (複数モデル対応済み) ======
    window.addEventListener('keydown', (ev) => {
      if (!activeModel) return;

      const k = ev.key;
      // scale
      if (k === '[' || k === ']') {
        const s = activeModel.getAttribute('scale');
        const f = (k === '[') ? 0.9 : 1.1;
        const nx = s.x * f, ny = s.y * f, nz = s.z * f;
        activeModel.setAttribute('scale', `${nx} ${ny} ${nz}`);
        console.log(`[ADJ] ${activeModel.id} scale = ${nx.toFixed(6)}`);
      }
      // yaw
      if (k === 'ArrowLeft' || k === 'ArrowRight') {
        const r = activeModel.getAttribute('rotation');
        const delta = (k === 'ArrowLeft') ? -5 : 5;
        const ny = r.y + delta;
        activeModel.setAttribute('rotation', `${r.x} ${ny} ${r.z}`);
        console.log(`[ADJ] ${activeModel.id} rotation = ${r.x} ${ny} ${r.z}`);
      }
      // pitch
      if (k === 'ArrowUp' || k === 'ArrowDown') {
        const r = activeModel.getAttribute('rotation');
        const delta = (k === 'ArrowUp') ? -5 : 5;
        const nx = r.x + delta;
        activeModel.setAttribute('rotation', `${nx} ${r.y} ${r.z}`);
        console.log(`[ADJ] ${activeModel.id} rotation = ${nx} ${r.y} ${r.z}`);
      }
    });
  </script>
</body>
</html>